---
title: "simulation & inference of transients"
author: "Carl Boettiger"
date: "5/30/2019"
output: html_document
---

```{r}
library(tidyverse)
```

```{r}
constants <- list(N = 1e3,
#                  x0 = 0.2,
                  r = 0.05, 
                  K = 2,
#                  mu_a = 0,     sd_a = 1,
#                  mu_sigma = 0, sd_sigma = 1,
#                  mu_Q = 0,     sd_Q = 1,
#                  mu_H = 0,     sd_h = 1,
                  Q = 5,
                  H = 0.38, 
                  sigma = 0.01,
                  a = 0.023
                  )

params <- list()

p <- c(params, constants)
growth <- function(x) x * p$r * (1 - x / p$K)
consumption <- function(x) p$a * x^p$Q / (x^p$Q + p$H^p$Q)
```

```{r}
theory <- 
  tibble(x= seq(0,2, length.out = 100)) %>%
  mutate(g = growth(x), 
         c = consumption(x)) %>%
  mutate(potential = - cumsum(g - c)) %>%
  gather(curve, y, -x, -potential) 
```

```{r noisy_switch}
theory %>%
  ggplot(aes(x, y, col = curve)) +
  geom_line(lwd = 1)
```

```{r}
theory %>%
  ggplot(aes(x, potential)) + 
  geom_line(lwd = 1)
```

```{r}
library(nimble)
# Define stochastic model in BUGS notation
may  <- nimble::nimbleCode({
  x[1] <- x0
  y[1] <- x0
  
  #a ~ dlnorm(mu_a, sd_a)
  for(t in 1:(N-1)){
    # Determinstic mean looks like standard R
    mu[t] <- x[t] + x[t] * r * (1 - x[t] / K)  - a * x[t] ^ Q / (x[t] ^ Q + H ^ Q)
    # Note the use of ~ in BUGS to show 'distributed as lognormal' 
    y[t+1] ~ dnorm(mu[t], sd = sigma)
    x[t+1] <- max(y[t+1],0)
  }
})
inits <- params
#inits$a <- 0.01
model <- nimbleModel(code = may, constants = constants, inits = list(x0 = 0.2))
```

```{r simulate, cache = F}
set.seed(123)

simulate(model, nodes = c('mu', 'x'))
df <- tibble(t = seq_along(model$x), x = model$x)

model$setData(list(x = model$x))
model$initializeInfo()

```


```{r}
df%>% ggplot(aes(t, x)) + geom_line()
```





```{r}
#cmodel$a <- 0.01
# confirm we are now good to go

cmodel <- compileNimble(model)

```


```{r estimation}
## block sampler
system.time({
  mcmcConf <- configureMCMC(cmodel)
  mcmcConf$getMonitors()
  #mcmcConf$removeSampler(c("a"))
  #mcmcConf$addSampler(target = c("a"), type = 'RW_block')
  #mcmcConf$getMonitors()
})
```

```{r}
system.time({
  mcmc <- buildMCMC(mcmcConf)
  Cmcmc <- compileNimble(mcmc, project = model)
})
```

```{r}
mcmcConf$getMonitors()
n_iterations <- 1e6
system.time({
  Cmcmc$run(n_iterations, nburnin = n_iterations / 2, thin = 1e2)
})
```


```{r}
samples <- as.matrix(Cmcmc$mvSamples)
draws <- as_data_frame(samples) %>% mutate(t = seq_along(a)) %>% gather(var,value, -t)
ggplot(draws, aes(t, value)) + geom_line() + facet_wrap(~var, scales = "free")
```

```{r}
matplot(samples, type = "l", lty = 1)
legend("top", horiz = T, lty = 1, col = 1:4, legend = colnames(samples), bty = "n")
abline(h = lapply(p, log), col = 1:4)
corrplot::corrplot(cor(samples))
```

